<!DOCTYPE html>
<html>
<head>
	<title>USB Test</title>
	<style>
		@font-face {
			font-family: 'stealth57';
			src: url('Assets/stealth57.ttf');
		}
		button {
			font-family: stealth57;
		}
		canvas {
			image-rendering: pixelated;
		}
		canvas, svg {
			position: absolute;
			width: 640px;
			height: 480px;
			top: 30px;
			left: 10px;
		}
		svg text {
			font-family: 'stealth57';
			font-size: 16px;
		}
	</style>
</head>
<body>
	<button id="connect">Connect</button>

	<div>
		<canvas id="canvas" width="320" height="240"></canvas>
		<svg id="svg" width="320" height="240"></svg>
	</div>

	<script>

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const textNodes = [];

function buildText() {
	const xmlns = 'http://www.w3.org/2000/svg';
	const svg = document.getElementById('svg');

	while (svg.firstChild) {
		svg.removeChild(svg.lastChild);
	}

	for (let y = 0; y < 25; y++) {
		for (let x = 0; x < 39; x++) {
			const e = document.createElementNS(xmlns, 'text');
			e.setAttributeNS(null, 'x', x * 16);
			e.setAttributeNS(null, 'y', y * 20 + 20);
			e.setAttributeNS(null, 'fill', '#a0e');
			const t = document.createTextNode('');
			e.appendChild(t);
			svg.appendChild(e);

			textNodes[y * 39 + x] = t;
		}
	}
}

buildText();

function processRect(frame) {
	// [x x] [y y] [w w] [h h] [r] [g] [b]
	const x = frame[1] + frame[2] * 256;
	const y = frame[3] + frame[4] * 256;
	const w = frame[5] + frame[6] * 256;
	const h = frame[7] + frame[8] * 256;
	const r = frame[9];
	const g = frame[10];
	const b = frame[11];

	// console.log(`RECT ${w}x${h} @ ${x},${y} (${r.toString(16)} ${g.toString(16)} ${b.toString(16)})`);

	ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
	ctx.fillRect(x, y, w, h);
}

function processText(frame) {
	// [c] [x x] [y y] [r] [g] [b]
	const c = String.fromCharCode(frame[1]);
	const x = frame[2] + frame[3] * 256;
	const y = frame[4] + frame[5] * 256;
	const r = frame[6];
	const g = frame[7];
	const b = frame[8];

	// console.log(`'${c}' @ ${x},${y} (${r.toString(16)} ${g.toString(16)} ${b.toString(16)})`);

	// ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
	// ctx.fillText(c, x, y + 10);

	const i = Math.floor(y / 10) * 39 + Math.floor(x / 8);
	if (textNodes[i]) {
		textNodes[i].nodeValue = c;
		textNodes[i].parentElement.setAttributeNS(null, 'fill', `rgb(${r}, ${g}, ${b})`);
	}
}

function processFrame(frame) {
	const type = frame[0];
	switch (type) {
		case 0xfe:
			if (frame.length >= 12) {
				processRect(frame);
			} else {
				console.log('Bad RECT frame');
			}
			break;

		case 0xfd:
			if (frame.length >= 9) {
				processText(frame);
			} else {
				console.log('Bad TEXT frame');
			}
			break;

		case 0xfc: // wave
		case 0xfb: // joypad
			break;

		default:
			console.log('BAD FRAME');
	}
}

let inState = 'normal';
const inFrame = [];

function processIn(dataView) {
	for (let i = 0; i < dataView.byteLength; i++) {
		const b = dataView.getUint8(i);

		switch (inState) {
			case 'normal':
				switch (b) {
					case 0xc0:
						processFrame(inFrame);
						inFrame.length = 0;
						break;

					case 0xdb:
						inState = 'escape';
						break;

					default:
						inFrame.push(b);
						break;
				}
				break;

			case 'escape':
				switch (b) {
					case 0xdc:
						inFrame.push(0xc0);
						inState = 'normal';
						break;

					case 0xdd:
						inFrame.push(0xdb);
						inState = 'normal';
						break;

					default:
						inState = 'error';
						console.log('Unexpected SLIP sequence');
						break;
				}
				break;

			case 'error':
				switch (b) {
					case 0xc0:
						inState = 'normal';
						inFrame.length = 0;
						console.log('SLIP recovered');
						break;

					default:
						break;
				}
		}
	}
}

function resetIn() {
	inState = 'normal';
	inFrame.length = 0;
}

let device;

function readIn() {
	if (!device)
		return;

	return device.transferIn(3, 512)
		.then(result => {
			if (result.status !== 'ok') {
				console.log(result);
			} else {
				processIn(result.data);
			}

			return readIn();
		});
}

function reset() {
	return device
		.transferOut(3, new Uint8Array([0x44]))
		.then(() => wait(50))
		.then(() => {
			resetIn();
			return device.transferOut(3, new Uint8Array([0x45, 0x52]));
		})
		.catch(disconnect);
}

function disconnect(error) {
	device = null;
	console.error(error);
}

document
	.getElementById('connect')
	.addEventListener('click', () => {
		if (device)
			return;

		navigator.usb.getDevices()
			.then(devices => {
				device = devices.filter(d =>
					d.vendorId === 0x16c0 &&
					d.productId === 0x048a)[0];

				if (device) {
					inState = 'normal';
					inFrame.length = 0;
					return device;

				} else {
					return navigator.usb.requestDevice({
						filters: [{
							vendorId: 0x16c0,
							productId: 0x048a
						}]
					});
				}
			})
			.then(selectedDevice => {
				device = selectedDevice;
				return device.open();
			})
			.then(() => device.selectConfiguration(1))
			.then(() => device.claimInterface(1))
			.then(() => device.controlTransferOut(
				{
					requestType: 'class',
					recipient: 'interface',
					request: 0x22,
					value: 0x03,
					index: 0x01
				}))
			.then(() => device.controlTransferOut(
				{
					requestType: 'class',
					recipient: 'interface',
					request: 0x20,
					value: 0x00,
					index: 0x01
				},
				new Uint8Array([0x80, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08])))
			.then(() => reset())
			.then(() => readIn())
			.catch(disconnect);
	});

let keyState = 0;
const keyMap = {
	ArrowUp: 6,
	ArrowDown: 5,
	ArrowLeft: 7,
	ArrowRight: 2,
	ShiftLeft: 4,
	Space: 3,
	KeyZ: 1,
	KeyX: 0
};

function sendKeyState() {
	if (!device)
		return;

	device
		.transferOut(3, new Uint8Array([0x43, keyState]))
		.catch(disconnect);
}

document
	.addEventListener('keydown', e => {
		const bit = keyMap[e.code];
		if (bit !== undefined) {
			e.preventDefault();
			const newState = keyState | (1 << bit);
			if (newState !== keyState) {
				keyState = newState;
				sendKeyState();
			}
		}
	});

document
	.addEventListener('keyup', e => {
		const bit = keyMap[e.code];
		if (bit !== undefined) {
			e.preventDefault();
			const newState = keyState & ~(1 << bit);
			if (newState !== keyState) {
				keyState = newState;
				sendKeyState();
			}
		}
	});

function deviceInfo() {
	const info = device.configuration.interfaces
		.flatMap(i => i.alternates[0].endpoints.map(ep => ({
			ifNum: i.interfaceNumber,
			class: i.alternates[0].interfaceClass,
			subClass: i.alternates[0].interfaceSubclass,
			protocol: i.alternates[0].interfaceProtocol,
			epNum: ep.endpointNumber,
			epDir: ep.direction,
			epType: ep.type,
			epPacketSize: ep.packetSize
		})));
	console.table(info);
}
</script>

</body>
</html>
