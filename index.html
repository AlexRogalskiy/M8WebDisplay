<!DOCTYPE html>
<!--
	Copyright 2021 James Deery
	Released under the MIT licence, https://opensource.org/licenses/MIT
 -->
<html>
<head>
	<title>M8 Display</title>
	<style>
		@font-face {
			font-family: 'stealth57';
			src: url('Assets/stealth57.ttf');
		}
		button {
			font-family: stealth57;
		}
		canvas {
			image-rendering: pixelated;
		}
		canvas, svg {
			position: absolute;
			width: 640px;
			height: 480px;
			top: 30px;
			left: 10px;
		}
		svg text {
			font-family: 'stealth57';
			font-size: 16px;
		}
	</style>
</head>
<body>
	<button id="connect" autofocus>Connect</button>

	<div>
		<canvas id="canvas" width="320" height="240"></canvas>
		<svg id="svg" width="320" height="240"></svg>
	</div>

	<script>

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const textNodes = [];

function buildText() {
	const xmlns = 'http://www.w3.org/2000/svg';
	const svg = document.getElementById('svg');

	while (svg.firstChild) {
		svg.removeChild(svg.lastChild);
	}

	for (let y = 0; y < 25; y++) {
		for (let x = 0; x < 39; x++) {
			const e = document.createElementNS(xmlns, 'text');
			e.setAttributeNS(null, 'x', x * 16);
			e.setAttributeNS(null, 'y', y * 20 + 20);
			e.setAttributeNS(null, 'fill', '#000');
			const t = document.createTextNode('');
			e.appendChild(t);
			svg.appendChild(e);

            textNodes[y * 39 + x] = {
                node: t,
                char: ' ',
                fill: '#000'
            };
		}
	}
}

buildText();

function processRect(frame) {
	// [x x] [y y] [w w] [h h] [r] [g] [b]
	const x = frame[1] + frame[2] * 256;
	const y = frame[3] + frame[4] * 256;
	const w = frame[5] + frame[6] * 256;
	const h = frame[7] + frame[8] * 256;
	const r = frame[9];
	const g = frame[10];
	const b = frame[11];

	ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
	ctx.fillRect(x, y, w, h);

    if (x === 0 && y === 0 && w === 320 && h === 240) {
        document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    }
}

let textUpdates = {};
let textFrameQueued = false;

function updateText() {
    for (const [_, update] of Object.entries(textUpdates)) {
        const node = update.node;
        if (update.char !== node.char) {
            node.node.nodeValue = update.char;
            node.char = update.char;
        }
        if (update.fill !== node.fill) {
            node.node.parentElement.setAttributeNS(null, 'fill', update.fill);
            node.fill = update.fill;
        }
    }

    textFrameQueued = false;
    textUpdates = {};
}

function processText(frame) {
	// [c] [x x] [y y] [r] [g] [b]
	const c = String.fromCharCode(frame[1]);
	const x = frame[2] + frame[3] * 256;
	const y = frame[4] + frame[5] * 256;
	const r = frame[6];
	const g = frame[7];
	const b = frame[8];

	const i = Math.floor(y / 10) * 39 + Math.floor(x / 8);
	if (textNodes[i]) {
        textUpdates[i] = {
            node: textNodes[i],
            char: c,
            fill: `rgb(${r}, ${g}, ${b})`
        };
        if (!textFrameQueued) {
            requestAnimationFrame(updateText);
            textFrameQueued = true;
        }
	}
}

function processFrame(frame) {
	const type = frame[0];
	switch (type) {
		case 0xfe:
			if (frame.length >= 12) {
				processRect(frame);
			} else {
				console.log('Bad RECT frame');
			}
			break;

		case 0xfd:
			if (frame.length >= 9) {
				processText(frame);
			} else {
				console.log('Bad TEXT frame');
			}
			break;

		case 0xfc: // wave
		case 0xfb: // joypad
			break;

		default:
			console.log('BAD FRAME');
	}
}

let inState = 'normal';
const inFrame = [];

function processIn(dataView) {
	for (let i = 0; i < dataView.byteLength; i++) {
		const b = dataView.getUint8(i);

		switch (inState) {
			case 'normal':
				switch (b) {
					case 0xc0:
						processFrame(inFrame);
						inFrame.length = 0;
						break;

					case 0xdb:
						inState = 'escape';
						break;

					default:
						inFrame.push(b);
						break;
				}
				break;

			case 'escape':
				switch (b) {
					case 0xdc:
						inFrame.push(0xc0);
						inState = 'normal';
						break;

					case 0xdd:
						inFrame.push(0xdb);
						inState = 'normal';
						break;

					default:
						inState = 'error';
						console.log('Unexpected SLIP sequence');
						break;
				}
				break;

			case 'error':
				switch (b) {
					case 0xc0:
						inState = 'normal';
						inFrame.length = 0;
						console.log('SLIP recovered');
						break;

					default:
						break;
				}
		}
	}
}

function resetIn() {
	inState = 'normal';
	inFrame.length = 0;
}

let device;

function readIn() {
	if (!device)
		return;

	return device.transferIn(3, 512)
		.then(result => {
			if (result.status !== 'ok') {
				console.log(result);
			} else {
				processIn(result.data);
			}

			return readIn();
		});
}

function reset() {
	return device
		.transferOut(3, new Uint8Array([0x44]))
		.then(() => wait(50))
		.then(() => {
			resetIn();
			return device.transferOut(3, new Uint8Array([0x45, 0x52]));
		})
		.catch(disconnect);
}

function disconnect(error) {
	device = null;
	console.error(error);
}

function connect() {
	if (device)
		return;

	navigator.usb.getDevices()
		.then(devices => {
			device = devices.filter(d =>
				d.vendorId === 0x16c0 &&
				d.productId === 0x048a)[0];

			if (device) {
				inState = 'normal';
				inFrame.length = 0;
				return device;

			} else {
				return navigator.usb.requestDevice({
					filters: [{
						vendorId: 0x16c0,
						productId: 0x048a
					}]
				});
			}
		})
		.then(selectedDevice => {
			device = selectedDevice;
			return device.open();
		})
		.then(() => device.selectConfiguration(1))
		.then(() => device.claimInterface(1))
		.then(() => device.controlTransferOut(
			{
				requestType: 'class',
				recipient: 'interface',
				request: 0x22,
				value: 0x03,
				index: 0x01
			}))
		.then(() => device.controlTransferOut(
			{
				requestType: 'class',
				recipient: 'interface',
				request: 0x20,
				value: 0x00,
				index: 0x01
			},
			new Uint8Array([0x80, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08])))
		.then(() => reset())
		.then(() => readIn())
		.catch(disconnect);
}

let keyState = 0;
const keyMap = {
	ArrowUp: 6,
	ArrowDown: 5,
	ArrowLeft: 7,
	ArrowRight: 2,
	ShiftLeft: 4,
	Space: 3,
	KeyZ: 1,
	KeyX: 0
};

document
	.getElementById('connect')
	.addEventListener('click', () => {
		startAudio();
		connect();
	});

function sendKeyState() {
	if (!device)
		return;

	device
		.transferOut(3, new Uint8Array([0x43, keyState]))
		.catch(disconnect);
}

document
	.addEventListener('keydown', e => {
		const bit = keyMap[e.code];
		if (bit !== undefined) {
			e.preventDefault();
			const newState = keyState | (1 << bit);
			if (newState !== keyState) {
				keyState = newState;
				sendKeyState();
			}
		}
	});

document
	.addEventListener('keyup', e => {
		const bit = keyMap[e.code];
		if (bit !== undefined) {
			e.preventDefault();
			const newState = keyState & ~(1 << bit);
			if (newState !== keyState) {
				keyState = newState;
				sendKeyState();
			}
		}
	});

function deviceInfo() {
	const info = device.configuration.interfaces
		.flatMap(i => i.alternates[0].endpoints.map(ep => ({
			ifNum: i.interfaceNumber,
			class: i.alternates[0].interfaceClass,
			subClass: i.alternates[0].interfaceSubclass,
			protocol: i.alternates[0].interfaceProtocol,
			epNum: ep.endpointNumber,
			epDir: ep.direction,
			epType: ep.type,
			epPacketSize: ep.packetSize
		})));
	console.table(info);
}

let audio;

function startAudio() {
	if (audio) {
		return audio
			.close()
			.then(() => {
				audio = null;
				return startAudio();
			});
	}

	audio = new AudioContext();

	navigator.mediaDevices
		.getUserMedia({ audio: true })
		.then(stream => navigator.mediaDevices
			.enumerateDevices())
		.then(devices => {
			const device = devices.filter(d =>
				d.kind === 'audioinput' &&
				/M8/.test(d.label) &&
				d.deviceId !== 'default' &&
				d.deviceId !== 'communications')[0];

			if (!device)
				throw new Error('M8 not found');

			return device.deviceId;
		})
		.then(deviceId => navigator.mediaDevices
			.getUserMedia({ audio: {
				deviceId: { exact: deviceId },
				autoGainControl: false,
				echoCancellation: false,
				noiseSuppression: false
			} }))
		.then(stream => {
			const source = audio.createMediaStreamSource(stream);
			source.connect(audio.destination);
		})
		.catch(err => console.log(err));
}
</script>
</body>
</html>
